from sage.all import *
from pwn import remote, context
import time
from Crypto.Util.number import long_to_bytes, inverse
from hashlib import sha256
# context.log_level = 'debug'
def calckl(klmode,kaddlmode,e):
    ksubl2 = kaddlmode**2-4*klmode
    PR = PolynomialRing(GF(e),'x')
    x = PR.gen()
    f = x**2-ksubl2
    kllist = []
    for ksublmode,_ in f.roots():
        k = int((ksublmode+kaddlmode) * inverse_mod(2,e) %e)
        l = int((kaddlmode - k) % e)
        assert (k + l)% e == kaddlmode
        kllist.append((k,l))
    return kllist
def get_kblind_or_lblind(k_l_, e , k,l , bound):
    import cuso
    x = var('x') 
    for a in [k,l]:
        relations = [x * int(e) + a == 0] 
        roots = cuso.find_small_roots(
            relations, 
            {x: bound}, 
            modulus="p",
            modulus_multiple=k_l_,
            modulus_lower_bound = int(sqrt(k_l_)) )  
        print(roots)
        if roots == []:
            continue
        ret = roots[0]["p"] 
        return ret,a
def recover_p_method1(dpMSB,dqMSB,k_calc,e, N, dlBound):  

    dpLSB_k_calc = int((inverse_mod(e, k_calc) * (1 - e * dpMSB)) % k_calc) 
    dqLSB_k_calc = int((inverse_mod(e, k_calc) * (1 - e * dqMSB)) % k_calc)   

    print(dpLSB_k_calc, dqLSB_k_calc)
    print((dp_ - dpMSB) % k_calc, (dq_ - dqMSB) % k_calc)

    if k_calc>dlBound:
        dpnow = dpMSB + dpLSB_k_calc
        dqnow = dqMSB + dqLSB_k_calc
        p = gcd(int(pow(2,dpnow,N) - 2),N)
        if p != 1:
            return p
        else: 
            return gcd(int(pow(2,dqnow,N) - 2),N)
    
    import cuso

    Bounds = dlBound // k_calc + 1 
    for dp_mod_k in [dpMSB + dpLSB_k_calc, dqMSB + dqLSB_k_calc]:
        x = var("x")  
        dp_now = int(k_calc) * x + int(dp_mod_k)
        ### check
        print((dp_ - dp_mod_k) % k_calc,(dp_ - dp_mod_k) // k_calc < Bounds) 
        print((dq_ - dp_mod_k) % k_calc,(dq_ - dp_mod_k) // k_calc < Bounds) 
        ### check
        f = e * dp_now - 1 + k_calc
        # e * dp' - 1 + k_calc = 0 % p
        relations = [f]
        bounds = {x: Bounds}

        while 1:
            try:
                roots = cuso.find_small_roots(
                    relations,
                    bounds,
                    modulus = "p",
                    modulus_multiple = N,
                    modulus_lower_bound = 2**(Nbit//2 - 1),
                ) 
                break
            except:
                time.sleep(1)
                continue

        print(roots)
        if len(roots) > 0:
            p = roots[0]["p"]
            return p
Nbit = 3072
alpha = 1/18
gamma = 1/20
delta = 8/25# 1/4 
alphabit = int(alpha * Nbit)
gammabit = int(gamma * Nbit)
deltabit = int(delta * Nbit)
unknownbit = 983
nbit = 3072
blind_bit = 153
e_bit = 170

start_time = time.time()
io = remote("34.150.83.54", 31659)
io.recvuntil(b"option >")
io.send(b"G") 
io.recvuntil(b"dp,dq:")
dp_, dq_ = eval(io.recvline().strip().decode())
io.recvuntil(b"n,e:")
N,e = eval(io.recvline().strip().decode())[0]
print(time.time() - start_time)
start_time = time.time()
dp_ = dp_ << unknownbit
dq_ = dq_ << unknownbit
A = e**2 * (dp_) * (dq_) // N + 1
klmode = A % e 
kaddlmode = (1-A*(N-1)) % e
k,l = calckl(klmode,kaddlmode,e)[0]  
kblind, a = get_kblind_or_lblind(A, e, k, l, 2**gammabit)

if a == k:
    kblind = kblind
    lblind = A // kblind
else:
    lblind = kblind
    kblind = A // lblind 


p = recover_p_method1(dp_, dq_, kblind, e, N, 2**deltabit) 
q = N//p
d = inverse(e, (p-1)*(q-1))

print(time.time() - start_time)

io.sendline(b'F')
io.recvuntil(b'Encrypted Token: ')
enctoken = int(io.recvline().strip().decode(), 16)
token = int(pow(enctoken, d, N))
tokenhash =sha256(long_to_bytes(token)).hexdigest()
io.recvuntil(b'Token Hash: ')
io.sendline(tokenhash.encode())
io.interactive()