from sage.all import*
from pwn import process, remote
from itertools import product
from tqdm import tqdm

class lcg:
    def __init__(self,state3,seed):
        state0 = seed ^ 0x77777777# a

        state2 = 2147483647 # m
        state1 = 2025 # b
    
        self.state = [state0,state1,state2,state3]

    def next(self):
        state = self.state # x
        result = (state[1] + state[0] * state[3]) % (2**32) % state[2];
        self.state[3] = result  
        return result

def shuffle_deck(rng):
    deck = (
        bytearray(range(16))
        + bytearray(range(16, 32))
        + bytearray(b" !\"#$%&'()*+,-./0123")
    )
    for i in range(len(deck) - 1, 0, -1):
        j = rng.next() % (i + 1)
        deck[i], deck[j] = deck[j], deck[i]  # 交换牌
    return deck

def index_to_card(index):
    if index < 13:  # Spades
        suit = "s"
        value_idx = index
    elif index < 26:  # Hearts
        suit = "h"
        value_idx = index - 13
    elif index < 39:  # Clubs
        suit = "c"
        value_idx = index - 26
    elif index < 52:  # Diamonds
        suit = "d"
        value_idx = index - 39
    else:
        return "??"  # For any unexpected values

    card_values = "A23456789XJQK"
    return suit + card_values[value_idx]

def card_to_index(card):
    cards = "sA s2 s3 s4 s5 s6 s7 s8 s9 sX sJ sQ sK hA h2 h3 h4 h5 h6 h7 h8 h9 hX hJ hQ hK cA c2 c3 c4 c5 c6 c7 c8 c9 cX cJ cQ cK dA d2 d3 d4 d5 d6 d7 d8 d9 dX dJ dQ dK".split()
    return cards.index(card)

io = remote("s1.r3.ret.sh.cn", "31124")
# io = process("../challenge/build/spadesace") 
io.recvline()
cards = io.recvline().strip().split(b" ") 
seed_lst = []
result_lst = []

for _ in tqdm(range(12)):
    seed = io.recvline().split(b" ")[-1].strip() 
    io.recvline()
    io.sendline(b"sA " * 52)
    io.recvline()
    cards = io.recvline().strip().split(b" ")  
    indexes = [card_to_index(card.decode()) for card in cards] 
    seed_lst.append(int(seed.decode(),16))
    result_lst.append(indexes[-1])

def fuck_a(xs,cs):
    overflowmod = 2**32
    mod = 2147483647
    b   = 2025 
    aas = []
    for itemtemp in tqdm(product([0,1],repeat=len(xs))):
        # print(itemtemp)
        newtarget = [(cs[i] + mod * itemtemp[i] - b) % overflowmod for i in range(len(cs))]

        L = matrix(ZZ,len(newtarget)+2,len(newtarget)+2)
        smmod = 13

        for i in range(len(newtarget)):
            L[ i,i] = overflowmod * smmod
            L[-2,i] = int(xs[i] * inverse_mod(smmod,overflowmod) % overflowmod) * smmod
            L[-1,i] = int(newtarget[i] * inverse_mod(smmod,overflowmod) % overflowmod) * smmod
        L[-1,-1] = overflowmod
        L[-2,-2] = 1
        ret = L.LLL()
        for Li in ret:
            if (Li[-1]) == overflowmod: 
                sign = Li[-1]//overflowmod 
                if all([ sign*ti<0 for ti in Li[:-2]]) and(Li[-2]^0x77777777)<2**31:
                    # print(Li)
                    aa =int((-sign*Li[-2])%mod) 
                    # print(aa)
                    print(Li[:-2])
                    print(aa)
                    aas.append(aa)
    return aas[0]

a = fuck_a(seed_lst,result_lst)  
io.recvuntil(b'seed: ')
x = int(io.recvline().strip().decode(),16) 
rng = lcg(state3 = x, seed = a^0x77777777)
ret = shuffle_deck(rng)
newdeck = " ".join(index_to_card(i) for i in ret).encode()
io.recv()
io.sendline(newdeck)
io.interactive()